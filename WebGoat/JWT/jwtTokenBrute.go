//This thing has a bug, and still haven't implemented ip and port usage.

package main

import (
        "bytes"
        "crypto/hmac"
        "crypto/sha256"
        "encoding/base64"
        "flag"
        "fmt"
        "io/ioutil"
        "strings"
)

type Methods interface {
        BruteJwt()
}

type JWT struct {
        ip    string
        port  string
        token string
}

type Brute struct {
        jwt      JWT
        wordlist string
}

func hmacBase64(key, message []byte) []byte {
        hash := hmac.New(sha256.New, key)
        hash.Write(message)
        digest := hash.Sum(nil)

        // Perform base64 URL encoding on the digest.
        base64URL := base64.RawURLEncoding.EncodeToString(digest)

        return []byte(base64URL)
}

func (b *Brute) BruteJwt() {
        token := b.jwt.token

        parts := strings.Split(token, ".")
        if len(parts) != 3 {
                fmt.Println("Invalid JWT token format")
                return
        }

        header := parts[0]
        payload := parts[1]
        signature := parts[2]

        decodedHeader, err := base64.RawURLEncoding.DecodeString(header)
        if err != nil {
                fmt.Println("Error decoding the header:", err)
                return
        }

        decodedPayload, err := base64.RawURLEncoding.DecodeString(payload)
        if err != nil {
                fmt.Println("Error decoding the payload:", err)
                return
        }

        fmt.Println("Decoded Header:", string(decodedHeader))
        fmt.Println("Decoded Payload:", string(decodedPayload))

        unsignedToken := fmt.Sprintf("%s.%s", decodedHeader, decodedPayload)

        fmt.Println("unsigned_token:", string(unsignedToken))

        paddingLen := (4 - len(signature)%4) % 4
        signaturePadding := strings.Repeat("=", paddingLen)
        signatureBytes := []byte(signature + signaturePadding)

        // Read the content of the file.
        content, err := ioutil.ReadFile(b.wordlist)
        if err != nil {
                fmt.Println("Error reading the file:", err)
                return
        }

        // Split the content by newlines to get individual words.
        words := string(content)
        wordlist := strings.Split(words, "\n")

        // Access the wordlist using the struct.
        for _, word := range wordlist {
                verify := hmacBase64([]byte(word), []byte(unsignedToken))
                // Convert the verify value to raw bytes to compare with signatureBytes.
                verifyBytes, err := base64.RawURLEncoding.DecodeString(string(verify))
                if err != nil {
                        fmt.Println("Error decoding verify:", err)
                        return
                }
                if bytes.Equal(verifyBytes, signatureBytes) {
                        fmt.Printf("Key: %s\n", word)

                        newToken := fmt.Sprintf("%s.%s", header, strings.TrimRight(base64.RawURLEncoding.EncodeToString([]byte(payload)), "="))
                        newSignature := hmacBase64([]byte(word), []byte(newToken))
                        newToken = fmt.Sprintf("%s.%s", newToken, strings.TrimRight(string(newSignature), "="))
                        fmt.Println("New Token:", newToken)
                        return
                } else {
                        fmt.Println("Wrong Key=>", word)
                }
        }

        fmt.Println("Key not found in the wordlist.")
}

func callMethods(methods Methods) {
        methods.BruteJwt()
}

func main() {
        var ip string
        var port string
        var token string
        var wordlist string

        flag.StringVar(&ip, "ip", "", "Ip Address to bruteforce JWT")
        flag.StringVar(&port, "port", "", "Port")
        flag.StringVar(&token, "token", "", "Token")
        flag.StringVar(&wordlist, "wordlist", "", "Wordlist")

        flag.Parse()

        jwt_struct := JWT{
                ip:    ip,
                port:  port,
                token: token,
        }

        brute_struct := Brute{
                jwt:      jwt_struct,
                wordlist: wordlist,
        }

        if token == "" {
                fmt.Println("Token is required")
                return
        } else if wordlist == "" {
                fmt.Println("Wordlist is required")
                return
        } else if token != "" && wordlist != "" {
                callMethods(&brute_struct)
        }
}
